/**
 * @file tkl_display.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2024 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_display.h"
#include "tuya_error_code.h"
#include "tkl_system.h"

#include "disp_spi_driver.h"
// --- END: user defines and implements ---

struct _fush_buf
{
    TKL_DISP_RECT_S disp_rect;
    uint8_t *buffer;
    TKL_DISP_PIXEL_FMT_E format;
};


static struct _fush_buf fush_buf;
static TKL_DISP_EVENT_HANDLER_S *disp_event_handler = NULL;

static void disp_flush_ready_async(void)
{
    if (disp_event_handler == NULL)
        return;

    if (disp_event_handler->vsync_cb) {
        disp_event_handler->vsync_cb(0, tkl_system_get_tick_count());
    }
}

/**
 * @brief timer init
 * 
 * @param[in] timer_id timer id
 * @param[in] cfg timer configure
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_disp_init(TKL_DISP_DEVICE_S *display_device, TKL_DISP_EVENT_HANDLER_S *event_handler)
{
    disp_event_handler = event_handler;
    disp_driver_init(disp_flush_ready_async);

    return OPRT_OK;
}

OPERATE_RET tkl_disp_deinit(TKL_DISP_DEVICE_S *display_device)
{
    //todo
    return OPRT_OK;
}

OPERATE_RET tkl_disp_set_info(TKL_DISP_DEVICE_S *display_device, TKL_DISP_INFO_S *info)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_get_info(TKL_DISP_DEVICE_S *display_device, TKL_DISP_INFO_S *info)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_blit(TKL_DISP_DEVICE_S *display_device, TKL_DISP_FRAMEBUFFER_S *buf, TKL_DISP_RECT_S *rect)
{
    if (buf->format != TKL_DISP_PIXEL_FMT_RGB565) {
        PR_ERR("unsupport pixel format %d\n", buf->format);
        return OPRT_INVALID_PARM;
    }

    if (buf->buffer != NULL && rect->height > 0 && rect->width > 0) {
        fush_buf.disp_rect.height = rect->height;
        fush_buf.disp_rect.width = rect->width;
        fush_buf.disp_rect.x = rect->x;
        fush_buf.disp_rect.y = rect->y;
        fush_buf.buffer = (uint8_t *)buf->buffer;
        fush_buf.format = buf->format;

        return OPRT_OK;
    }

    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_fill(TKL_DISP_DEVICE_S *display_device, TKL_DISP_RECT_S *rect, TKL_DISP_COLOR_U color)
{
    disp_driver_set_color(rect->x, rect->y, rect->x + rect->width - 1, rect->y + rect->height - 1, color.full & 0xFFFF);
	return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_flush(TKL_DISP_DEVICE_S *display_device)
{
    if (fush_buf.buffer != NULL && fush_buf.disp_rect.height > 0 && fush_buf.disp_rect.width > 0) {
        disp_driver_flush(fush_buf.disp_rect.x, fush_buf.disp_rect.y, fush_buf.disp_rect.x + fush_buf.disp_rect.width - 1, fush_buf.disp_rect.y + fush_buf.disp_rect.height - 1, (uint8_t *)fush_buf.buffer);
    } else {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

OPERATE_RET tkl_disp_wait_vsync(TKL_DISP_DEVICE_S *display_device)
{

    return OPRT_OK;
}

TKL_DISP_FRAMEBUFFER_S *tkl_disp_alloc_framebuffer(TKL_DISP_DEVICE_S *display_device)
{
    return NULL;
}

void tkl_disp_free_framebuffer(TKL_DISP_DEVICE_S *display_device, TKL_DISP_FRAMEBUFFER_S *buf)
{
}

OPERATE_RET tkl_disp_get_capabilities(TKL_DISP_DEVICE_S *display_device, TKL_DISP_INFO_S **cfg)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_free_capabilities(TKL_DISP_DEVICE_S *display_device, TKL_DISP_INFO_S *cfg)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_set_brightness(TKL_DISP_DEVICE_S *display_device, int brightness)
{
    if((brightness > 255) || (brightness < 0)) {
        return OPRT_INVALID_PARM;
    }
    disp_driver_set_bright(brightness * 100 / 255);
    return OPRT_OK;
}

OPERATE_RET tkl_disp_get_brightness(TKL_DISP_DEVICE_S *display_device, int *brightness)
{
    *brightness = disp_driver_get_bright() * 255 / 100;
    return OPRT_OK;
}

OPERATE_RET tkl_disp_get_power_mode(TKL_DISP_DEVICE_S *display_device, TKL_DISP_POWER_MODE_E *power_mode)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_disp_set_power_mode(TKL_DISP_DEVICE_S *display_device, TKL_DISP_POWER_MODE_E power_mode)
{
    return OPRT_NOT_SUPPORTED;
}
